{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"scala-algorithm"},{"location":"/index.html#scala-algorithm","text":"Data Structures and Algorithms in Scala Programming Language\nScaladoc","title":"scala-algorithm"},{"location":"/binexp.html","text":"","title":"Binary Exponentiation"},{"location":"/binexp.html#binary-exponentiation","text":"algo.algebra.binexp\nðŸš§WIP","title":"Binary Exponentiation"},{"location":"/bloom-filter.html","text":"","title":"Bloom Filter"},{"location":"/bloom-filter.html#bloom-filter","text":"algo.data.bloom provides implementations of Bloom filter, which can store a large amount of data by allowing small errors. There are the two following implementations:\nimmutable.BloomFilter mutable.BloomFilter","title":"Bloom Filter"},{"location":"/bloom-filter.html#creating-a-bloomfilter-instance","text":"BloomFilter.apply method creates an instance of BloomFilter as the following:\nImmutable import HashFunctionFactory.Implicits.default\n\nval bloomFilter: immutable.BloomFilter[String] =\n  immutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001) Mutable import HashFunctionFactory.Implicits.default\n\nval bloomFilter: mutable.BloomFilter[String] =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nBloomFilter.apply method takes two parameters capacity and tolerance. Further, BloomFilter also takes an instance of HashFunctionFactory as a context (implicit) parameter. These parameters determine the characteristics of BloomFilter.","title":"Creating a BloomFilter instance"},{"location":"/bloom-filter.html#characteristics","text":"Parameters the capacity and tolerance are tunable for a false positive probability. The false positive probability is less than the tolerance if the number of items BloomFilter contains is less than or equal to the capacity. If a lower false positive probability is required, use a higher capacity or a lower tolerance.\nBased on the capacity and tolerance, BloomFilter determines hash space (the number of bits) and the number of hash functions to use. BloomFilter requires a larger hash space and more hash functions if a higher capacity or lower tolerance is requested. In other words, BloomFilter requires a larger hash space if it should achieve a lower false positive probability.\nNote that the capacity is not the hard limit of the number of items BloomFilter can contain. While BloomFilter can contain more items than the capacity, it cannot achieve a lower false positive probability than the tolerance.","title":"Characteristics"},{"location":"/bloom-filter.html#getting-parameters","text":"BloomFilter provides functions returning parameters the following:\nThe capacity The tolerance The number of bits The number of hash functions\nImmutable val bloomFilter =\n  immutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\n\n// Getting the capacity\nassert(bloomFilter.capacity == 1_000_000)\n\n// Getting the tolerance\nassert(bloomFilter.tolerance == 0.001)\n\n// Getting the number of bits\nassert(bloomFilter.numOfBits == 14_377_588)\n\n// Getting the number of hash functions\nassert(bloomFilter.numOfHashFunctions == 10) Mutable val bloomFilter =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\n\n// Getting the capacity\nassert(bloomFilter.capacity == 1_000_000)\n\n// Getting the tolerance\nassert(bloomFilter.tolerance == 0.001)\n\n// Getting the number of bits\nassert(bloomFilter.numOfBits == 14_377_588)\n\n// Getting the number of hash functions\nassert(bloomFilter.numOfHashFunctions == 10)","title":"Getting parameters"},{"location":"/bloom-filter.html#adding-an-item","text":"BloomFilter provides add method to add the given item to itself:\nImmutable val bloomFilter =\n  immutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\n\nval newBloomFilter: immutable.BloomFilter[String] =\n  bloomFilter.add(\"item1\") Mutable val bloomFilter =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\n\nbloomFilter.add(\"item1\")\nadd method of immutable.BloomFilter returns a new BloomFilter having the given item. add method of mutable.BloomFilter updates itself to contain the given item. In both, BloomFilter increments its size by one if it doesnâ€™t have the given item.","title":"Adding an item"},{"location":"/bloom-filter.html#testing-membership-of-an-item","text":"BloomFilter provides contains method to test whether BloomFilter contains the given item or not:\nImmutable val bloomFilter =\n  immutable\n    .BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(!bloomFilter.contains(\"item1\"))\n\nval newBloomFilter = bloomFilter.add(\"item1\")\nassert(newBloomFilter.contains(\"item1\")) Mutable val bloomFilter =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(!bloomFilter.contains(\"item1\"))\n\nbloomFilter.add(\"item1\")\nassert(bloomFilter.contains(\"item1\"))\ncontains method returns true if BloomFilter contains the given item. Note that BloomFilter can return true if it doesnâ€™t have the given item but has the other item with the same hash value, which is a false positive case. In contrast, BloomFilter doesnâ€™t return false if it has the given item.","title":"Testing membership of an item"},{"location":"/bloom-filter.html#getting-the-size-and-false-positive-probability","text":"BloomFilter provides size method to get the number of items it has:\nImmutable val bloomFilter =\n  immutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(bloomFilter.size == 0)\n\nval newBloomFilter = bloomFilter.add(\"item1\")\nassert(newBloomFilter.size == 1) Mutable val bloomFilter =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(bloomFilter.size == 0)\n\nbloomFilter.add(\"item1\")\nassert(bloomFilter.size == 1)\nBloomFilter also provides falsePositiveProbability method to get the current false positive probability:\nImmutable val bloomFilter =\n  immutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(bloomFilter.falsePositiveProbability == 0.0)\n\nval newBloomFilter = bloomFilter.add(\"item1\")\nprintln(newBloomFilter.falsePositiveProbability == 2.6493427380062913e-62) Mutable val bloomFilter =\n  mutable.BloomFilter[String](capacity = 1_000_000, tolerance = 0.001)\nassert(bloomFilter.falsePositiveProbability == 0.0)\n\nbloomFilter.add(\"item1\")\nassert(bloomFilter.falsePositiveProbability == 2.6493427380062913e-62)","title":"Getting the size and false positive probability"},{"location":"/bloom-filter.html#hash-function-factory","text":"BloomFilter, a probabilistic collection, hashes the given item using hash functions. The hash functions are crucial for a false positive probability. HashFunctionFactory creates these hash functions.\nHashFunctionFactory.Implicits.default provides the default implementation of HashFunctionFactory. This default is easier to use but might not be a suitable performance. It is possible to implement a custom HashFunctionFactory as the following:\nimplicit def customHashFunctionFactory[T]: HashFunctionFactory[T] =\n  new HashFunctionFactory[T] {\n    override def apply(index: Int): T => Int = {\n      // Return a hash function for the given index.\n      ???\n    }\n  }","title":"Hash Function Factory"},{"location":"/quick-select.html","text":"","title":"Quick Select"},{"location":"/quick-select.html#quick-select","text":"algo.util\nðŸš§WIP","title":"Quick Select"},{"location":"/stack.html","text":"","title":"Stack"},{"location":"/stack.html#stack","text":"algo.data.stack\nðŸš§WIP","title":"Stack"},{"location":"/queue.html","text":"","title":"Queue"},{"location":"/queue.html#queue","text":"algo.data.queue\nðŸš§WIP","title":"Queue"},{"location":"/heap.html","text":"","title":"Heap"},{"location":"/heap.html#heap","text":"algo.data.heap\nðŸš§WIP","title":"Heap"},{"location":"/fenwick.html","text":"","title":"Fenwick Tree"},{"location":"/fenwick.html#fenwick-tree","text":"algo.data.fenwick\nðŸš§WIP","title":"Fenwick Tree"},{"location":"/dsu.html","text":"","title":"Disjoint Set Union"},{"location":"/dsu.html#disjoint-set-union","text":"algo.data.dsu\nðŸš§WIP","title":"Disjoint Set Union"}]}